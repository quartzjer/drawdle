<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Drawdle</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #f5f5f5;
      margin: 0;
      padding: 20px;
    }
    .container {
      max-width: 700px;
      margin: 0 auto;
      background: #fff;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    h1 {
      text-align: center;
      margin-bottom: 20px;
    }
    #svgContainer {
      border: 1px solid #eee;
      border-radius: 4px;
      padding: 15px;
      background: #fff;
      min-height: 200px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }
    .svg-container svg {
      max-width: 100%;
      height: auto;
      border-radius: 4px;
      background: white;
    }
    svg path,
    svg line,
    svg rect,
    svg circle,
    svg ellipse {
      stroke-linecap: round;
      stroke-linejoin: round;
      fill: none;
    }
    .chat-container {
      display: flex;
      margin-top: 15px;
    }
    #chatInput {
      flex: 1;
      font-size: 14px;
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    #sendButton, #resetButton {
      padding: 10px 15px;
      margin-left: 10px;
      border: none;
      border-radius: 4px;
      font-size: 14px;
      cursor: pointer;
      color: #fff;
    }
    #sendButton {
      background-color: #007BFF;
    }
    #sendButton:hover {
      background-color: #0056b3;
    }
    #resetButton {
      background-color: #6c757d;
    }
    #resetButton:hover {
      background-color: #5a6268;
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
  </style>
</head>
<body>

<!-- Include Vivus via CDN -->
<script src="https://cdn.jsdelivr.net/npm/vivus@0.4.6/dist/vivus.min.js"></script>

<div class="container">
  <h1>drawdle</h1>
  <div id="svgContainer" class="svg-container">
    <!-- Our main SVG to hold all paths -->
    <svg id="mainSvg" width="600" height="400" viewBox="0 0 600 400"
         style="border:1px solid #ccc; width:600px; height:400px;">
      <!-- Existing lines or newly added lines will stay here -->
    </svg>
  </div>

  <div class="chat-container">
    <input type="text" id="chatInput" placeholder="Describe something to draw..." autofocus />
    <button id="sendButton">Send</button>
    <button id="resetButton">Reset</button>
  </div>
</div>

<script>
  const chatInput = document.getElementById('chatInput');
  const sendButton = document.getElementById('sendButton');
  const resetButton = document.getElementById('resetButton');
  const mainSvg = document.getElementById('mainSvg');
  let socket = null;
  let isAnimating = false;
  let pathQueue = [];
  const speedFactor = 8.0; // bigger=faster

  // Process next path in queue
  function processQueue() {
    if (isAnimating) return;
    if (!pathQueue.length) return;
    isAnimating = true;

    // Mark all existing lines as data-ignore="true" so they won't re-animate
    Array.from(mainSvg.children).forEach(el => {
      el.setAttribute('data-ignore', 'true');
    });

    // Get next path; do NOT set data-ignore on it, so Vivus will animate it
    const pathToAnimate = pathQueue.shift();
    mainSvg.appendChild(pathToAnimate);

    // Assign data-duration by path length to match uniform speed
    const length = pathToAnimate.getTotalLength();
    pathToAnimate.setAttribute('data-duration', length / speedFactor);

    // We create a Vivus instance on the entire SVG but it will skip lines with data-ignore
    new Vivus(
      'mainSvg', 
      {
        type: 'scenario',     // each path drawn in order
        start: 'manual',      // we control when animation starts
        forceRender: false    // try turning this on/off if IE needs help
      }, 
      () => {
        // After animation completes, the path is fully drawn
        isAnimating = false;

        // If more lines are queued, animate next
        if (pathQueue.length) {
          processQueue();
        }
      }
    ).play();
  }

  function sendMessage() {
    const message = chatInput.value.trim();
    if (!message || socket) return;
    sendButton.disabled = true;
    sendButton.textContent = 'Sending...';

    // Open WebSocket (adjust path to your server if needed)
    socket = new WebSocket(`ws://${window.location.host}/ws`);
    socket.onopen = () => {
      socket.send(message);
      chatInput.value = '';
    };

    // When we receive a new path, parse it into a DOM element
    socket.onmessage = (event) => {
      const parser = new DOMParser();
      const svgWrap = parser.parseFromString(
        `<svg xmlns="http://www.w3.org/2000/svg">${event.data}</svg>`,
        'image/svg+xml'
      );
      // Grab the first node inside that <svg> (usually <path>)
      const newPath = svgWrap.documentElement.firstChild;

      // Store ID as <title> for clarity
      const title = document.createElementNS("http://www.w3.org/2000/svg", "title");
      title.textContent = newPath.getAttribute('id');
      newPath.appendChild(title);

      // Add it to queue
      pathQueue.push(newPath);
      // Attempt to process the queue if not already animating
      if (!isAnimating) processQueue();
    };

    socket.onclose = () => {
      sendButton.disabled = false;
      sendButton.textContent = 'Send';
      socket = null;
    };
    socket.onerror = () => {
      sendButton.disabled = false;
      sendButton.textContent = 'Send';
      socket = null;
    };
  }

  sendButton.addEventListener('click', sendMessage);
  chatInput.addEventListener('keypress', e => {
    if (e.key === 'Enter') sendMessage();
  });

  // Clear the main SVG
  resetButton.addEventListener('click', () => {
    mainSvg.innerHTML = '';
  });
</script>

</body>
</html>
